#! /usr/bin/perl -w
#
# This is the API part of UsersPluginFingerprintReader plugin -
# configuration of user's fingerprints on specific device
#

package UsersPluginFingerprintReader;

use strict;

use YaST::YCP qw(:LOGGING);
use YaPI;
use Data::Dumper;

textdomain("fingerprint-reader");

our %TYPEINFO;

##--------------------------------------
##--------------------- global imports

YaST::YCP::Import ("Directory");
YaST::YCP::Import ("FileUtils");
YaST::YCP::Import ("FingerprintReader");
YaST::YCP::Import ("Pam");
YaST::YCP::Import ("SCR");

##--------------------------------------
##--------------------- global variables

# error message, returned when some plugin function fails
my $error	= "";

my $fingerprint_reader_available = undef;

my $name	= "UsersPluginFingerprintReader";
   
##----------------------------------------
##--------------------- internal functions

# internal function:
# check if given key (second parameter) is contained in a list (1st parameter)
# if 3rd parameter is true (>0), ignore case
sub contains {
    my ($list, $key, $ignorecase) = @_;
    if (!defined $list || ref ($list) ne "ARRAY" || @{$list} == 0) {
	return 0;
    }
    if ($ignorecase) {
        if ( grep /^\Q$key\E$/i, @{$list} ) {
            return 1;
        }
    } else {
        if ( grep /^\Q$key\E$/, @{$list} ) {
            return 1;
        }
    }
    return 0;
}

# helper, check if Fingerprint Reader was already configured
sub fingerprint_reader_configured {

    return Pam->Enabled ("fp");
}

# helper function: check if Fingerprint Reader (the device) is available
sub is_fingerprint_reader_available {

    if (not defined $fingerprint_reader_available) {
	my @devices	= @{FingerprintReader->ReadFingerprintReaderDevices ()};
	$fingerprint_reader_available = (@devices > 0);
    }
    return $fingerprint_reader_available;
}

# check if given user has fingerprint authentication configured
sub fingerprint_present {

    my ($data)	= @_;
    my $home	= $data->{"homeDirectory"};
    return 0 if !$home;
    my $org_home= $data->{"org_user"}{"homeDirectory"} || $home;
    return (FileUtils->IsDirectory ("$org_home/.fprint/prints"));
}

# check if fingerprint directory corresponds with username
sub adapt_fingerprint_info {

    my ($config, $data) = @_;
    my $username	= $data->{"uid"};

    my $fingerprint_dir	= $data->{"_fingerprint_dir"};

    # if _fingerprint_dir is not defined, plugin UI wasn't called (yet) 
    # and we don't need to solve user renaming, as the files will be moved
    # together with a home directory

    # but we need to move temporary directory if it exists and user was renamed:
    if ($fingerprint_dir && $fingerprint_dir ne $username) {
	my $tmp_dir	= Directory->tmpdir ();
	my $new_dir	= "$tmp_dir/$username";
y2internal ("tmp dir $tmp_dir, new $new_dir");
	# there might be some directory related to deleted user - remove it:
	SCR->Execute (".target.bash", "/bin/rm -rf $new_dir");
	# move the current tmp directory
	SCR->Execute (".target.bash",
	    "/bin/mv $tmp_dir/$fingerprint_dir $new_dir");
	# reflect the renaming in the data hash
	$data->{"_fingerprint_dir"}	= $username;
    }

    return $data;
}

# update the object data when removing plugin
sub remove_plugin_data {

    my ($config, $data)		= @_;
    $data->{"_fingerprint_dir"}	= "";
    $data->{"plugin_modified"}	= 1;
    return $data;
}

##------------------------------------------
##--------------------- global API functions

# All functions have 2 "any" parameters: these mean:
# 1st: configuration map (hash) - e.g. saying if we work with user or group
# 2nd: data map (hash) of user/group to work with
# for details, see UsersPluginLDAPAll.pm

# return names of provided functions
BEGIN { $TYPEINFO{Interface} = ["function", ["list", "string"], "any", "any"];}
sub Interface {

    my $self		= shift;
    my @interface 	= (
	    "GUIClient",
	    "Name",
	    "Summary",
	    "Restriction",
	    "Interface",
	    "PluginPresent",
	    "PluginRemovable",
	    "Error",
	    "AddBefore",
	    "Add",
	    "EditBefore",
	    "Edit",
	    "Delete",
	    "Write"
    );
    return \@interface;
}

# return error message, generated by plugin
BEGIN { $TYPEINFO{Error} = ["function", "string", "any", "any"];}
sub Error {

    my $self		= shift;
    return $error;
}


# return plugin name, used for GUI (translated)
BEGIN { $TYPEINFO{Name} = ["function", "string", "any", "any"];}
sub Name {

    my $self		= shift;
    # plugin name
    return __("Fingerprint configuration");
}

##------------------------------------
# return plugin summary (to be shown in table with all plugins)
BEGIN { $TYPEINFO{Summary} = ["function", "string", "any", "any"];}
sub Summary {

    my $self	= shift;
    # plugin summary (table item)
    my $ret 	= __("Set the User's Fingerprint");
    return $ret;
}

##------------------------------------
# checks the current data map of user (2nd parameter) and returns
# true if given user has our plugin
BEGIN { $TYPEINFO{PluginPresent} = ["function", "boolean", "any", "any"];}
sub PluginPresent {

    my ($self, $config, $data)  = @_;
    return 0 if not fingerprint_reader_configured ();

    if (contains ($data->{'plugins'}, $name, 1) || fingerprint_present ($data))
    {
	y2milestone ("$name plugin present");
	return 1;
    }
    return 0;
}

##------------------------------------
# Is it possible to remove this plugin from user?
BEGIN { $TYPEINFO{PluginRemovable} = ["function", "boolean", "any", "any"];}
sub PluginRemovable {
    # doesn't have sense to remove
    return YaST::YCP::Boolean (1);
}


##------------------------------------
# return name of YCP client defining YCP GUI
BEGIN { $TYPEINFO{GUIClient} = ["function", "string", "any", "any"];}
sub GUIClient {

    return "users_plugin_fingerprint_reader";
}

##------------------------------------
# Type of objects this plugin is restricted to.
# It defines:
#	1. type of objects which it should be applied to (ldap/nis/local/system)
#	2. type of objects at all (user)
# If this function doesn't exist, plugin is applied for all users of all types
BEGIN { $TYPEINFO{Restriction} = ["function",
    ["map", "string", "any"], "any", "any"];}
sub Restriction {

    my $self	= shift;
    # do the check here, so the plugin is not shown when there is no hw for it
    return {} if not is_fingerprint_reader_available ();
    return {
	    "local"	=> 1,
	    "system"	=> 1,
	    # only for users
	    "user"	=> 1,
    };
}

# this will be called at the beggining of Users::Add
# Could be called multiple times for one user
BEGIN { $TYPEINFO{AddBefore} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub AddBefore {

    my ($self, $config, $data)  = @_;

    if (!fingerprint_reader_configured ()) {
	# error popup
	$error	= __("Fingerprint reader is not configured. Run 'yast2-fingerprint-reader' to configure it");
	return undef;
    }
    return $data;
}

# This will be called at the end of Users::Add* :
# modify the object map with fingerprint-reader data
BEGIN { $TYPEINFO{Add} = ["function", ["map", "string", "any"], "any", "any"];}
sub Add {

    my ($self, $config, $data)  = @_;
    if (contains ($data->{'plugins_to_remove'}, $name, 1)) {
	y2milestone ("removing plugin $name...");
	return remove_plugin_data ($config, $data);
    }
    return adapt_fingerprint_info ($config, $data);
}

# this will be called at the beggining of Users::Edit
BEGIN { $TYPEINFO{EditBefore} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub EditBefore {

    my ($self, $config, $data)  = @_;

    if (!fingerprint_reader_configured ()) {
	# error popup
	$error	= __("Fingerprint reader is not configured. Run 'yast2-fingerprint-reader' to configure it");
	return undef;
    }
    return $data;
}

# This will be called at the end of Users::Edit* :
# modify the object map with fingerprint-reader data
BEGIN { $TYPEINFO{Edit} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub Edit {

    my ($self, $config, $data)  = @_;
    # "plugins_to_remove" is list of plugins which are set for removal
    if (contains ($data->{'plugins_to_remove'}, $name, 1)) {
	y2milestone ("removing plugin $name...");
	return remove_plugin_data ($config, $data);
    }
    return adapt_fingerprint_info ($config, $data);
}


# What should be done after user is finally written (this is called only once):
# - move temporary directory with fingerprints to correct location ($HOME)
BEGIN { $TYPEINFO{Write} = ["function", "boolean", "any", "any"];}
sub Write {

    my ($self, $config, $data)  = @_;

    my $username	= $data->{"uid"};
    my $fingerprint_dir	= $data->{"_fingerprint_dir"};

    return YaST::YCP::Boolean (0) if (!$username);

    if ($fingerprint_dir) {
	my $tmp_dir	= Directory->tmpdir ();
	$fingerprint_dir= "$tmp_dir/$fingerprint_dir/.fprint";
	my $home	= $data->{"homeDirectory"};
	if (!$home) {
	    y2warning ("home directory empty or not defined");
	    return YaST::YCP::Boolean (0);
	}
	my $uid		= $data->{"uidNumber"};
	my $gid		= $data->{"gidNumber"};

	my $command = "/bin/chown -R $uid:$gid $fingerprint_dir";
y2internal ("command: $command");
	my %out     = %{SCR->Execute (".target.bash_output", $command)};
	if (($out{"stderr"} || "") ne "") {
	    y2error ("error calling $command: ", $out{"stderr"} || "");
	    return YaST::YCP::Boolean (0);
	}
	else {
	    y2milestone ("moving $fingerprint_dir to $home/");
	    SCR->Execute (".target.bash","/bin/cp -ar $fingerprint_dir $home/");
	}
    }
    return YaST::YCP::Boolean (1);
}


42
# EOF
