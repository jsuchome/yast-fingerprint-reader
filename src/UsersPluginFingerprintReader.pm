#! /usr/bin/perl -w
#
# This is the API part of UsersPluginFingerprintReader plugin -
# configuration of user's fingerprints on specific device
#

package UsersPluginFingerprintReader;

use strict;

use YaST::YCP qw(:LOGGING);
use YaPI;
use Data::Dumper;

textdomain("users");

our %TYPEINFO;

##--------------------------------------
##--------------------- global imports

YaST::YCP::Import ("SCR");

##--------------------------------------
##--------------------- global variables

# error message, returned when some plugin function fails
my $error	= "";

my $fingerprint_reader_available = undef;
   
##----------------------------------------
##--------------------- internal functions

# helper, check if Fingerprint Reader was already configured
#FIXME do a pam-config query
sub fingerprint_reader_configured {

    return YaST::YCP::Boolean (1);
}

# helper function: check if Fingerprint Reader (the device) is available
sub is_fingerprint_reader_available {

    if (not defined $fingerprint_reader_available) {
	my @devices	= @{SCR->Read (".probe.fingerprint")};
	$fingerprint_reader_available = (@devices > 0);
    }
    return $fingerprint_reader_available;
}

##------------------------------------------
##--------------------- global API functions

# All functions have 2 "any" parameters: these mean:
# 1st: configuration map (hash) - e.g. saying if we work with user or group
# 2nd: data map (hash) of user/group to work with
# for details, see UsersPluginLDAPAll.pm

# return names of provided functions
BEGIN { $TYPEINFO{Interface} = ["function", ["list", "string"], "any", "any"];}
sub Interface {

    my $self		= shift;
    my @interface 	= (
	    "GUIClient",
	    "Name",
	    "Summary",
	    "Restriction",
	    "Interface",
	    "PluginPresent",
	    "PluginRemovable",
	    "Error",
	    "AddBefore",
	    "EditBefore",
    );
    return \@interface;
}

# return error message, generated by plugin
BEGIN { $TYPEINFO{Error} = ["function", "string", "any", "any"];}
sub Error {

    my $self		= shift;
    return $error;
}


# return plugin name, used for GUI (translated)
BEGIN { $TYPEINFO{Name} = ["function", "string", "any", "any"];}
sub Name {

    my $self		= shift;
    # plugin name
    return __("Fingerprint configuration");
}

##------------------------------------
# return plugin summary (to be shown in table with all plugins)
BEGIN { $TYPEINFO{Summary} = ["function", "string", "any", "any"];}
sub Summary {

    my $self	= shift;
    # plugin summary (table item)
    my $ret 	= __("Set the user's fingerprint");
    return $ret;
}

##------------------------------------
# checks the current data map of user (2nd parameter) and returns
# true if given user has our plugin
BEGIN { $TYPEINFO{PluginPresent} = ["function", "boolean", "any", "any"];}
sub PluginPresent {

    my $self	= shift;

    # it is present every time it is available
    return fingerprint_reader_configured ();
}

##------------------------------------
# Is it possible to remove this plugin from user?
BEGIN { $TYPEINFO{PluginRemovable} = ["function", "boolean", "any", "any"];}
sub PluginRemovable {
    # doesn't have sense to remove
    return YaST::YCP::Boolean (0);
}


##------------------------------------
# return name of YCP client defining YCP GUI
BEGIN { $TYPEINFO{GUIClient} = ["function", "string", "any", "any"];}
sub GUIClient {

    return "users_plugin_fingerprint_reader";
}

##------------------------------------
# Type of objects this plugin is restricted to.
# It defines:
#	1. type of objects which it should be applied to (ldap/nis/local/system)
#	2. type of objects at all (user)
# If this function doesn't exist, plugin is applied for all users of all types
BEGIN { $TYPEINFO{Restriction} = ["function",
    ["map", "string", "any"], "any", "any"];}
sub Restriction {

    my $self	= shift;
    # do the check here, so the plugin is not shown when there is no hw for it
    return {} if not is_fingerprint_reader_available ();
    return {
	    "local"	=> 1,
	    "system"	=> 1,
	    # only for users
	    "user"	=> 1,
    };
}

# this will be called at the beggining of Users::Add
# Could be called multiple times for one user
BEGIN { $TYPEINFO{AddBefore} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub AddBefore {

    my ($self, $config, $data)  = @_;

    if (!fingerprint_reader_configured ()) {
	# error popup
	$error	= __("Fingerprint reader is not configured. Run 'yast2-fingerprint-reader' to configure it");
	return undef;
    }
    return $data;
}

# this will be called at the beggining of Users::Edit
BEGIN { $TYPEINFO{EditBefore} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub EditBefore {

    my ($self, $config, $data)  = @_;

    if (!fingerprint_reader_configured ()) {
	# error popup
	$error	= __("Fingerprint reader is not configured. Run 'yast2-fingerprint-reader' to configure it");
	return undef;
    }
    return $data;
}

#FIXME in Write, solve user renaming


42
# EOF
